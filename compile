#!/usr/bin/ruby

# A ruby wrapper for gowacc.

# This file acts as a wrapper that calls the gowacc binary with correct flags.
# This file is also responsible for assembling, linking and execution.

require "optparse"


END {
  # Parse options
  parse_options()

  # Parse target file(s)
  files = get_target_files()

  exit_status = 0

  # Process each target file
  files.each do |file_path|
    # Call the gowacc compiler with requested flags,
    # save its exit status, and print its output
    output = %x(./gowacc #{$opts.join(" ")} #{file_path})
    exit_status = $?.exitstatus
    puts output

    # Assemble and execute, if requested
    program_name = (File.basename file_path)[0..-6]
    if ($options[:save_binary] || $options[:execute]) && exit_status == 0 then
      assemble(program_name)
      if $options[:execute] then
        execute(program_name)
      end
      if !$options[:save_binary] && File.file?(program_name) then
        File.delete(program_name)
      end
    end

    # Delete the generated asm file, if requested
    if $options[:delete_assembly] && File.file?("#{program_name}.s") then
      File.delete("#{program_name}.s")
    end

    puts "-- Finished"
  end

  exit exit_status
}


def parse_options()
  ARGV << "-h" if ARGV.empty?

  $options = {}
  $opts = []

  OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [OPTIONS] TARGET
  Compiles a wacc program file into an ARM assembly file, which is saved in th"\
  "e root directory.

  OPTIONS:"

    opts.separator "    ** Front End (Parsing and Semantic Checking) Options *"\
    "*"

    $options[:parse_only] = false
    opts.on("-p", "--parse_only",
      "Parse only (default: false). Check the input file for syntax errors and"\
      " generate an AST.") do
      $opts << "-parse"
      $options[:parse_only] = true
    end

    $options[:semantic_check] = false
    opts.on("-s", "--semantic_check",
      "Semantic check only (default: false). Parse the file for syntax and sem"\
      "antic errors and generate an AST." ) do
      $opts << "-semantic"
      $options[:semantic_check] = true
    end

    $options[:print_ast] = false
    opts.on("-t", "--print_ast",
      "View AST (default: false). Display AST generated by the parser." ) do
      $opts << "-ast"
      $options[:print_ast] = true
    end

    $options[:print_symbol_table] = false
    opts.on("-y", "--print_symbol_table",
      "View symbol table (default: false). Displays the symbol table generated"\
      " by the semantic analysis.") do
      $opts << "-table"
      $options[:print_symbol_table] = true
    end

    opts.separator ""
    opts.separator "    ** Back End (Code Generation) Options **"

    $options[:print_asm] = false
    opts.on("-a", "--print_asm",
      "View assembly (default: false). Display ARM assembly code generated by "\
      "the code generator." ) do
      $opts << "-asm"
      $options[:print_asm] = true
    end

    $options[:delete_assembly] = false
    opts.on("-r", "--delete_asm",
      "Delete assembly file (default: false). Delete the generated ARM assembl"\
      "y file, if present." ) do
      $options[:delete_assembly] = true
    end

    opts.separator ""
    opts.separator "    ** Assembling, Linking and Execution Options **"

    $options[:save_binary] = false
    opts.on("-b", "--binary",
      "Save binary file (default: false). Saves an assembled binary file in ro"\
      "ot directory." ) do
      $options[:save_binary] = true
    end

    $options[:execute] = false
    opts.on("-x", "--execute",
      "Execute (default: false). Emulate the generated ARM code and display it"\
      "s output." ) do
      $options[:execute] = true
    end

    opts.separator ""
    opts.separator "    ** Other Options **"

    $options[:directory] = false
    opts.on("-d", "--directory",
      "Give directory of wacc files (default: false)." ) do
      $options[:directory] = true
    end

    opts.on_tail("-h", "--help",
      "Show this message.") do
      puts opts
      puts ""
      puts "  TARGET: Path to wacc program file to compile (or target director"\
      "y if -dir option set)"
      exit
    end
  end.parse!
end


def get_target_files()
  files = []

  if $options[:directory] then
    # Add the results of a search to the array
    files += Dir.glob(File.join(ARGV[0], "**", "*.wacc"))
  else
    # Just add the target file to the array
    files << ARGV[0]
  end

  # Check that there is at least one file to process
  if files == [] then
    puts "Error: no file(s) targeted"
    exit 1
  end

  return files
end


def assemble(program_name)
  puts "-- Assembling and Linking..."
  assemble = "arm-linux-gnueabi-gcc -o #{program_name} -mcpu=arm1176jzf-s -mtu"\
  "ne=arm1176jzf-s #{program_name}.s"
  %x(#{assemble})
end


def execute(program_name)
  puts "-- Executing..."
  emulated = %x(qemu-arm -L /usr/arm-linux-gnueabi/ #{program_name})
  emulated_exit_status = $?.exitstatus
  puts "==========================================================="
  if emulated != "" then
    puts emulated
  end
  puts "==========================================================="
  puts "The exit code is #{emulated_exit_status}."
end
