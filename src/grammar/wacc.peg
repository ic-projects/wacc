// ProgramNode
START ←_ p:PROGRAM {
	return ret(p)
}

PROGRAM ← ss:(_ STRUCT)* _ "begin" fs:(__ FUNC)* _ stat:STATS _ "end" _ !. {

	main := NewFunctionNode(
		c.getPosition(),
		NewBaseTypeNode(VOID),
		NewIdentifierNode(c.getPosition(), ""),
		[]*ParameterNode{},
		stat.([]StatementNode),
	)

	functions := []*FunctionNode{}
	for _, f := range toSlice(fs) {
		functions = append(functions, getItem(f, 1).(*FunctionNode))
	}
	functions = append(functions, main)

	structs := []*StructNode{}
	for _, s := range toSlice(ss) {
		structs = append(structs, getItem(s, 1).(*StructNode))
	}

	return ret(NewProgram(structs, functions))

} / ss:(_ STRUCT)* _ "begin" fs:(__ FUNC)* _ "end" _ !. {

	functions := []*FunctionNode{}
	for _, f := range toSlice(fs) {
		functions = append(functions, getItem(f, 1).(*FunctionNode))
	}

	structs := []*StructNode{}
	for _, s := range toSlice(ss) {
		structs = append(structs, getItem(s, 1).(*StructNode))
	}

	err := errors.New("Program body empty")

	return NewProgram(structs, functions), err
}

STRUCT ← "struct" __ i:IDENT __ "is" __ ts:STRUCTINTERNALLIST? __ "end" {

	if ts != nil {

		return ret(NewStructNode(
			c.getPosition(),
			i.(*IdentifierNode),
			ts.([]*StructInternalNode),
		))

	} else {

		return ret(NewStructNode(
			c.getPosition(),
			i.(*IdentifierNode),
			[]*StructInternalNode{},
		))

	}
}

STRUCTINTERNALLIST ← s:STRUCTINTERNAL ss:(_ STRUCTINTERNAL)* {

	structList := []*StructInternalNode{s.(*StructInternalNode)}
	for _, p := range toSlice(ss) {
		structList = append(structList, getItem(p, 1).(*StructInternalNode))
	}

	return ret(structList)

}

STRUCTINTERNAL ← t:TYPE _ i:IDENT _ ';' {
	return ret(NewStructInternalNode(
		c.getPosition(),
		i.(*IdentifierNode),
		t.(TypeNode)))
}

// FunctionNode
FUNC ← t:TYPE _ i:IDENT _ '(' _ params:PARAMLIST? _ ')' _ "is" __ s:STATS
       _ "end" {

	stats := s.([]StatementNode)
	finalStat := stats[len(stats)-1]

	var err error
	if (!FinalStatIsValid(finalStat)) {
		name := strings.TrimPrefix(i.(*IdentifierNode).String(), "- ")
		errmsg := fmt.Sprintf(
			"Function \"%s\" is not ended with a return or an exit statement",
			name,
		)
		err = errors.New(errmsg)
	}

	if (params != nil) {
		return NewFunctionNode(
			c.getPosition(),
			t.(TypeNode),
			i.(*IdentifierNode),
			params.([]*ParameterNode),
			stats,
		), err
	}

	return NewFunctionNode(
		c.getPosition(),
		t.(TypeNode),
		i.(*IdentifierNode),
		[]*ParameterNode{},
		stats,
	), err

} / t:TYPE _ ident:RESERVED _ '(' _ params:PARAMLIST? _ ')' _ "is" __ s:STATS
    _ "end" {

	name := string(getItem(ident, 0).([]byte))
	errmsg := fmt.Sprintf("Invalid identifier, \"%s\" (reserved)", name)
	err := errors.New(errmsg)

	return NewFunctionNode(
		c.getPosition(),
		t.(TypeNode),
		NewIdentifierNode(c.getPosition(), name),
		[]*ParameterNode{},
		[]StatementNode{},
	), err

}

PARAMLIST ← param:PARAM params:(_ ',' _ PARAM)* {

	paramList := []*ParameterNode{param.(*ParameterNode)}
	for _, p := range toSlice(params) {
		paramList = append(paramList, getItem(p, 3).(*ParameterNode))
	}

	return ret(paramList)

}

// Parameter Node
PARAM ← t:TYPE _ i:IDENT {

	return ret(NewParameterNode(
		c.getPosition(),
		t.(TypeNode),
		i.(*IdentifierNode),
	))

}

// Spacing and Comments
_ "Optional Space" ← ([ \n\t\r] / COMMENT)*
__ "Obligatory Space" ← ([ \n\t\r] / COMMENT)+
COMMENT ← '#' ([^\n])* '\n'
