{
    package main

    import (
        "ast"
        "unicode/utf8"
        "strconv"
        "strings"
    )

    func (p position) getPosition() ast.Position {
        return ast.NewPosition(p.line, p.col, p.offset)
    }
}

PROGRAM <- _ "begin" fs:(__ FUNC)* _ stat:STAT _ "end" {
    main := ast.NewFunctionNode(
        c.pos.getPosition(),
        ast.NewBaseTypeNode(ast.INT),
        "main",
        []ast.ParameterNode{},
        stat.([]ast.StatementNode),
    )
    functions := []ast.FunctionNode{main}
    // for _, f := range fs.([]interface{}) {
    //     functions = append(functions, f.([]interface{})[1].(ast.FunctionNode))
    // }
    return ast.NewProgram(functions), nil
}

FUNC <- TYPE __ IDENT _ '(' _ PARAMLIST? _ ')' _ "is" __ STAT _ "end"
PARAMLIST <- PARAM (_ ',' _ PARAM)*
PARAM <- TYPE __ IDENT

STAT <- stat:(SKIP / NEWASSIGN / ASSIGN / READ / FREE / RETURN / EXIT / PRINT / PRINTLN / IF / WHILE / SCOPE) stats:(_ ';' _ (SKIP / NEWASSIGN / ASSIGN / READ / FREE / RETURN / EXIT / PRINT / PRINTLN / IF / WHILE / SCOPE))* {
    statements := []ast.StatementNode{stat}
    for _, s := range stats.([]interface{}) {
        statements = append(statements, s.([]interface{})[3].(ast.StatementNode))
    }
    return statements, nil
}

SKIP <- "skip" {
    return ast.NewSkipNode(c.pos.getPosition()), nil
}
NEWASSIGN <- t:TYPE __ ident:IDENT _ '=' _ rhs:ASSIGNRHS {
  return ast.NewDeclareNode(c.pos.getPosition(), t.(ast.TypeNode), ident.(string), rhs.(ast.RHSNode)), nil
}
ASSIGN <- lhs:ASSIGNLHS _ "=" _ rhs:ASSIGNRHS {
  return ast.NewAssignNode(c.pos.getPosition(), lhs.(ast.LHSNode), rhs.(ast.LHSNode)), nil
}
READ <- "read" __ lhs:ASSIGNLHS {
  return ast.NewReadNode(c.pos.getPosition(), lhs.(ast.LHSNode)), nil
}
FREE <- "free" __ expr:EXPR {
  return ast.NewFreeNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
RETURN <- "return" __ expr:EXPR {
  return ast.NewReturnNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
EXIT <- "exit" __ expr:EXPR {
  return ast.NewExitNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
PRINT <- "print" __ expr:EXPR {
  return ast.NewPrintNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
PRINTLN <- "println" __ expr:EXPR {
  return ast.NewPrintlnNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
IF <- "if" __ cond:EXPR _ "then" __ ifStats:STAT _ "else" __ elseStats:STAT _ "fi" {
  return ast.NewIfNode(c.pos.getPosition(), cond.(ast.ExpressionNode), ifStats.(ast.StatementNode).([]ast.StatementNode), elseStats.(ast.StatementNode).([]ast.StatementNode)), nil
}
WHILE <- "while" __ cond:EXPR _ "do" __ stats:STAT _ "done" {
  return ast.NewLoopNode(c.pos.getPosition(), cond.(ast.ExpressionNode), stats.(ast.StatementNode).([]ast.StatementNode)), nil
}
SCOPE <- "begin" __ stats:STAT _ "end" {
  return ast.NewScopeNode(c.pos.getPosition(), stats.(ast.StatementNode).([]ast.StatementNode)), nil
}

ASSIGNLHS <- PAIRELEM / ARRAYELEM / IDENT
ASSIGNRHS <- ARRAYLITER / NEWPAIR / PAIRELEM / CALL / EXPR
NEWPAIR <- "newpair" _ '(' _ EXPR _ ',' _ EXPR _ ')'
CALL <- "call" __ IDENT _ '(' _ ARGLIST? _ ')'
ARGLIST <- EXPR (_ ',' _ EXPR)*
PAIRELEM <- FST / SND
FST <- "fst" __ EXPR
SND <- "snd" __ EXPR

TYPE <- t:(BASETYPE / PAIRTYPE) array:(_ ARRAYTYPE)* {
    if (len(array.([]interface{})) > 0) {
        return ast.NewArrayTypeNode(t.(ast.TypeNode), len(array.([]interface{}))), nil
    }
    return t, nil
}
BASETYPE <- t:(INT / BOOL / CHAR / STRING) {
    return t, nil
}
INT <- "int" {
    return ast.NewBaseTypeNode(ast.INT), nil
}
BOOL <- "bool" {
    return ast.NewBaseTypeNode(ast.BOOL), nil
}
CHAR <- "char" {
    return ast.NewBaseTypeNode(ast.CHAR), nil
}
STRING <- "string" {
    return ast.NewBaseTypeNode(ast.STRING), nil
}
ARRAYTYPE <- '[' _ ']'
PAIRTYPE <- "pair" _ '(' _ PAIRELEMTYPE _ ',' _ PAIRELEMTYPE _ ')'

PAIRELEMTYPE <- ((BASETYPE / ARRAYTYPE) (_ ARRAYTYPE)*) / BASETYPE / PAIR
PAIR <- "pair"

EXPR <- ((BREXPR _ ')') / INTLITER / BOOLLITER / CHARLITER / STRLITER / PAIRLITER / (UNARYOPER _ EXPR) / ARRAYELEM / IDENT) (_ BINARYOPER _ EXPR)*
BREXPR <- '(' _ EXPR
UNARYOPER <- NOT / NEG / LEN / ORD / CHR
NOT <- '!'
NEG <- '-'
LEN <- "len"
ORD <- "ord"
CHR <- "chr"
BINARYOPER <- MULT / DIV / MOD / PLUS / SUB / GEQ / GT / LEQ / LT / EQ / NEQ / AND / OR
MULT <- '*'
DIV <- '/'
MOD <- '%'
PLUS <- '+'
SUB <- '-'
GT <- '>'
GEQ <- ">="
LT <- '<'
LEQ <- "<="
EQ <- "=="
NEQ <- "!="
AND <- "&&"
OR <- "||"


IDENT <- s:(('_' / [a-z] / [A-Z]) ('_' / [a-z] / [A-Z] / [0-9])*) {
  return string(c.text), nil
}

ARRAYELEM <- IDENT (_ '[' _ EXPR _ ']')+
INTLITER <- INTSIGN? _ DIGIT+ {
  i, _ := strconv.ParseInt(strings.Replace(string(c.text), " ", "", -1), 10, 32)
  return ast.NewIntegerLiteralNode(c.pos.getPosition(), int(i)), nil
}
DIGIT <- [0-9]
INTSIGN <- '+' / '-'
BOOLLITER <- TRUE / FALSE
TRUE <- "true" {
  return ast.NewBooleanLiteralNode(c.pos.getPosition(), true), nil
}
FALSE <- "false" {
  return ast.NewBooleanLiteralNode(c.pos.getPosition(), false), nil
}
CHARLITER <- "'" char:CHARACTER "'" {
  r, _ := utf8.DecodeRune(char.([]byte))
  return ast.NewCharacterLiteralNode(c.pos.getPosition(), r), nil
}
STRLITER <- '"' CHARACTER* '"' {
  return ast.NewStringLiteralNode(c.pos.getPosition(), string(c.text)), nil
}
CHARACTER <- [^""''\\] / '\\' ESCAPEDCHAR
ESCAPEDCHAR <- [0btnfr""''\\]
ARRAYLITER <- '[' _ (EXPR (_ ',' _ EXPR)*)? _ ']'
PAIRLITER <- "null"

/**** Comments and Spacing ****/

Comment <- '#' ([^\n])* '\n'

_ "Optional Space" <- ([ \n\t\r] / Comment)*
__ "Obligatory Space" <- ([ \n\t\r] / Comment)+
