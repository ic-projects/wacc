{
    package main

    import (
        "ast"
    )

    func (p position) getPosition() ast.Position {
        return ast.NewPosition(p.line, p.col, p.offset)
    }
}

PROGRAM <- _ "begin" fs:(__ FUNC)* _ stat:STAT _ "end" {
    main := ast.NewFunctionNode(
        c.pos.getPosition(),
        ast.NewBaseTypeNode(ast.INT),
        "main",
        []ast.ParameterNode{},
        stat.([]ast.StatementNode),
    )
    functions := []ast.FunctionNode{main}
    // for _, f := range fs.([]interface{}) {
    //     functions = append(functions, f.([]interface{})[1].(ast.FunctionNode))
    // }
    return ast.NewProgram(functions), nil
}

FUNC <- TYPE __ IDENT _ '(' _ PARAMLIST? _ ')' _ "is" __ STAT _ "end"
PARAMLIST <- PARAM (_ ',' _ PARAM)*
PARAM <- TYPE __ IDENT

STAT <- stat:(SKIP / NEWASSIGN / ASSIGN / READ / FREE / RETURN / EXIT / PRINT / PRINTLN / IF / WHILE / SCOPE) stats:(_ ';' _ (SKIP / NEWASSIGN / ASSIGN / READ / FREE / RETURN / EXIT / PRINT / PRINTLN / IF / WHILE / SCOPE))* {
    statements := []ast.StatementNode{stat}
    for _, s := range stats.([]interface{}) {
        statements = append(statements, s.([]interface{})[3].(ast.StatementNode))
    }
    return statements, nil
}

SKIP <- "skip" {
    return ast.NewSkipNode(c.pos.getPosition()), nil
}
NEWASSIGN <- t:TYPE __ ident:IDENT _ '=' _ rhs:ASSIGNRHS {
  return ast.NewDeclareNode(c.pos.getPosition(), t.(ast.TypeNode), ident.(string), rhs.(ast.RHSNode)), nil
}
ASSIGN <- lhs:ASSIGNLHS _ "=" _ rhs:ASSIGNRHS {
  return ast.NewAssignNode(c.pos.getPosition(), lhs.(ast.LHSNode), rhs.(ast.LHSNode)), nil
}
READ <- "read" __ lhs:ASSIGNLHS {
  return ast.NewReadNode(c.pos.getPosition(), lhs.(ast.LHSNode)), nil
}
FREE <- "free" __ expr:EXPR {
  return ast.NewFreeNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
RETURN <- "return" __ expr:EXPR {
  return ast.NewReturnNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
EXIT <- "exit" __ expr:EXPR {
  return ast.NewExitNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
PRINT <- "print" __ expr:EXPR {
  return ast.NewPrintNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
PRINTLN <- "println" __ expr:EXPR {
  return ast.NewPrintlnNode(c.pos.getPosition(), expr.(ast.ExpressionNode)), nil
}
IF <- "if" __ cond:EXPR _ "then" __ ifStats:STAT _ "else" __ elseStats:STAT _ "fi" {
  return ast.NewIfNode(c.pos.getPosition(), cond.(ast.ExpressionNode), ifStats.(ast.StatementNode).([]ast.StatementNode), elseStats.(ast.StatementNode).([]ast.StatementNode)), nil
}
WHILE <- "while" __ cond:EXPR _ "do" __ stats:STAT _ "done" {
  return ast.NewLoopNode(c.pos.getPosition(), cond.(ast.ExpressionNode), stats.(ast.StatementNode).([]ast.StatementNode)), nil
}
SCOPE <- "begin" __ stats:STAT _ "end" {
  return ast.NewScopeNode(c.pos.getPosition(), stats.(ast.StatementNode).([]ast.StatementNode)), nil
}

ASSIGNLHS <- PAIRELEM / ARRAYELEM / IDENT
ASSIGNRHS <- ARRAYLITER / NEWPAIR / PAIRELEM / CALL / EXPR
NEWPAIR <- "newpair" _ '(' _ t1:EXPR _ ',' _ t2:EXPR _ ')' {
    return ast.NewNewPairNode(c.pos.getPosition(), t1.(ast.ExpressionNode), t2.(ast.ExpressionNode)), nil
}
CALL <- "call" __ IDENT _ '(' _ ARGLIST? _ ')'
ARGLIST <- EXPR (_ ',' _ EXPR)*
PAIRELEM <- FST / SND
FST <- "fst" __ EXPR
SND <- "snd" __ EXPR

TYPE <- t:(BASETYPE / PAIRTYPE) array:(_ ARRAYTYPE)* {
    if (len(array.([]interface{})) > 0) {
        return ast.NewArrayTypeNode(t.(ast.TypeNode), len(array.([]interface{}))), nil
    }
    return t, nil
}
BASETYPE <- INT / BOOL / CHAR / STRING
INT <- "int" {
    return ast.NewBaseTypeNode(ast.INT), nil
}
BOOL <- "bool" {
    return ast.NewBaseTypeNode(ast.BOOL), nil
}
CHAR <- "char" {
    return ast.NewBaseTypeNode(ast.CHAR), nil
}
STRING <- "string" {
    return ast.NewBaseTypeNode(ast.STRING), nil
}
ARRAYTYPE <- '[' _ ']'
PAIRTYPE <- "pair" _ '(' _ t1:PAIRELEMTYPE _ ',' _ t2:PAIRELEMTYPE _ ')' {
    return ast.NewPairTypeNode(t1.(ast.TypeNode), t2.(ast.TypeNode)), nil
}

PAIRELEMTYPE <- (t:BASETYPE array:(_ ARRAYTYPE)*) {
    if (len(array.([]interface{})) > 0) {
        return ast.NewArrayTypeNode(t.(ast.TypeNode), len(array.([]interface{}))), nil
    }
    return t, nil
} / PAIR
PAIR <- "pair"

EXPR <- expr:((BREXPR _ ')') / INTLITER / BOOLLITER / CHARLITER / STRLITER / PAIRLITER / UNARYEXPR / ARRAYELEM / IDENT) binex:(_ BINARYOPER _ EXPR)? {
  if (binex != nil) {
    bineexp := binex.([]interface{})
    return ast.NewBinaryOperatorNode(c.pos.getPosition(), bineexp[1].(ast.BinaryOperator), expr.(ast.ExpressionNode), bineexp[3].(ast.ExpressionNode)), nil
  }
  return expr, nil
}

UNARYEXPR <- op:UNARYOPER _ expr:EXPR {
  return ast.NewUnaryOperatorNode(c.pos.getPosition(), op.(ast.UnaryOperator), expr.(ast.ExpressionNode)), nil
}

BREXPR <- '(' _ expr:(EXPR) {
  return expr, nil
}
UNARYOPER <- op:(NOT / NEG / LEN / ORD / CHR) {
  return op, nil
}
NOT <- '!' {
  return ast.NOT, nil
}
NEG <- '-' {
  return ast.NEG, nil
}
LEN <- "len" {
  return ast.LEN, nil
}
ORD <- "ord" {
  return ast.ORD, nil
}
CHR <- "chr" {
  return ast.CHR, nil
}
BINARYOPER <- op:(MULT / DIV / MOD / PLUS / SUB / GEQ / GT / LEQ / LT / EQ / NEQ / AND / OR) {
  return op, nil
}
MULT <- '*' {
  return ast.MUL, nil
}
DIV <- '/' {
  return ast.DIV, nil
}
MOD <- '%' {
  return ast.MOD, nil
}
PLUS <- '+' {
  return ast.ADD, nil
}
SUB <- '-' {
  return ast.SUB, nil
}
GT <- '>' {
  return ast.GT, nil
}
GEQ <- ">=" {
  return ast.GEQ, nil
}
LT <- '<' {
  return ast.LT, nil
}
LEQ <- "<=" {
  return ast.LEQ, nil
}
EQ <- "==" {
  return ast.EQ, nil
}
NEQ <- "!=" {
  return ast.NEQ, nil
}
AND <- "&&" {
  return ast.AND, nil
}
OR <- "||" {
  return ast.OR, nil
}


IDENT <- s:(('_' / [a-z] / [A-Z]) ('_' / [a-z] / [A-Z] / [0-9])*) {
  return string(c.text), nil
}

ARRAYELEM <- IDENT (_ '[' _ EXPR _ ']')+
INTLITER <- INTSIGN? _ DIGIT+
DIGIT <- [0-9]
INTSIGN <- '+' / '-'
BOOLLITER <- TRUE / FALSE
TRUE <- "true"
FALSE <- "false"
CHARLITER <- "'" CHARACTER "'"
STRLITER <- '"' CHARACTER* '"'
CHARACTER <- [^""''\\] / '\\' ESCAPEDCHAR
ESCAPEDCHAR <- [0btnfr""''\\]
ARRAYLITER <- '[' _ (EXPR (_ ',' _ EXPR)*)? _ ']'
PAIRLITER <- "null"

/**** Comments and Spacing ****/

Comment <- '#' ([^\n])* '\n'

_ "Optional Space" <- ([ \n\t\r] / Comment)*
__ "Obligatory Space" <- ([ \n\t\r] / Comment)+
