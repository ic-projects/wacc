// ProgramNode
START ←_ p:PROGRAM {
    return ret(p)
}

PROGRAM ← "begin" fs:(__ FUNC)* _ stat:STATS _ "end" _ !. {

	main := NewFunctionNode(
		c.getPosition(),
		NewBaseTypeNode(VOID),
		NewIdentifierNode(c.getPosition(), ""),
		[]*ParameterNode{},
		stat.([]StatementNode),
	)

	functions := []*FunctionNode{}
	for _, f := range toSlice(fs) {
		functions = append(functions, getItem(f, 1).(*FunctionNode))
	}
	functions = append(functions, main)

	return ret(NewProgram(functions))

} / "begin" fs:(__ FUNC)* _ "end" _ !. {

	functions := []*FunctionNode{}
	for _, f := range toSlice(fs) {
		functions = append(functions, getItem(f, 1).(*FunctionNode))
	}

	err := errors.New("Program body empty")

	return NewProgram(functions), err

}

// FunctionNode
FUNC ← t:TYPE __ i:IDENT _ '(' _ params:PARAMLIST? _ ')' _ "is" __ s:STATS
       _ "end" {

	stats := s.([]StatementNode)
	finalStat := stats[len(stats)-1]

	var err error
	if (!FinalStatIsValid(finalStat)) {
		name := strings.TrimPrefix(i.(*IdentifierNode).String(), "- ")
		errmsg := fmt.Sprintf(
			"Function \"%s\" is not ended with a return or an exit statement",
			name,
		)
		err = errors.New(errmsg)
	}

	if (params != nil) {
		return NewFunctionNode(
			c.getPosition(),
			t.(TypeNode),
			i.(*IdentifierNode),
			params.([]*ParameterNode),
			stats,
		), err
	}

	return NewFunctionNode(
		c.getPosition(),
		t.(TypeNode),
		i.(*IdentifierNode),
		[]*ParameterNode{},
		stats,
	), err

} / t:TYPE __ ident:RESERVED _ '(' _ params:PARAMLIST? _ ')' _ "is" __ s:STATS
    _ "end" {

	name := string(getItem(ident, 0).([]byte))
	errmsg := fmt.Sprintf("Invalid identifier, \"%s\" (reserved)", name)
	err := errors.New(errmsg)

	return NewFunctionNode(
		c.getPosition(),
		t.(TypeNode),
		NewIdentifierNode(c.getPosition(), name),
		[]*ParameterNode{},
		[]StatementNode{},
	), err

}

PARAMLIST ← param:PARAM params:(_ ',' _ PARAM)* {

	paramList := []*ParameterNode{param.(*ParameterNode)}
	for _, p := range toSlice(params) {
		paramList = append(paramList, getItem(p, 3).(*ParameterNode))
	}

	return ret(paramList)

}

// Parameter Node
PARAM ← t:TYPE __ i:IDENT {

	return ret(NewParameterNode(
		c.getPosition(),
		t.(TypeNode),
		i.(*IdentifierNode),
	))

}

// Spacing and Comments
_ "Optional Space" ← ([ \n\t\r] / COMMENT)*
__ "Obligatory Space" ← ([ \n\t\r] / COMMENT)+
COMMENT ← '#' ([^\n])* '\n'
