#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The 
\family typewriter
gowacc
\family default
 WACC Compiler
\end_layout

\begin_layout Author
Alexander Clarke (
\family typewriter
ac3716@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Qiang Feng (
\family typewriter
qf316@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Jordan Spooner (
\family typewriter
js4416@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Laurence Squires (
\family typewriter
ljs116@ic.ac.uk
\family default
)
\end_layout

\begin_layout Date
December 2017
\end_layout

\begin_layout Section
About the 
\family typewriter
gowacc
\family default
 Compiler
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
The 
\family typewriter
gowacc
\family default
 compiler is a tool, developed using Go, that compiles WACC source code
 into ARM assembly.
\end_layout

\begin_layout Subsubsection
Specification
\end_layout

\begin_layout Standard
We believe that our compiler largely meets the specification:
\end_layout

\begin_layout Paragraph
Lexical Analysis
\end_layout

\begin_layout Standard
Our compiler does not perform lexical analysis.
 We chose to use a parsing expression grammar, which means that lexing and
 parsing is performed in a single pass.
 This has some minor stylistic consequences in our grammar, but does not
 significantly affect how we meet much of the specification.
 It does, however, affect how much we can tell about errors.
 For example, consider the (incorrect) statement:
\begin_inset Formula 
\[
\texttt{intx = 3}
\]

\end_inset

Most parsers would store 
\family typewriter
intx
\family default
 as a token, thus allowing the compiler to identify the full token responsible
 for the error.
 Since we do not have tokens, detecting where an error ends is much more
 difficult, and was not supported by our parser generator.
 We forked our parser generator to add some additional functionality, however
 we didn't attempt to find the end of an error.
\end_layout

\begin_layout Standard
If we were to continue development on this compiler, we would probably choose
 to redevelop the parser using 
\family typewriter
goyacc
\family default
 instead of 
\family typewriter
pigeon
\family default
.
 This would allow us to improve the quality of error messages significantly,
 and would require less work than further forks to 
\family typewriter
pigeon
\family default
.
 It may also lead to increased performance in certain cases.
\end_layout

\begin_layout Paragraph
Syntactic Analysis
\end_layout

\begin_layout Standard
We carefully designed our AST from scratch, and tested it thoroughly against
 the reference compiler's AST, using the provided example programs as well
 as many of our own, more complex, example programs.
 We are confident that our internal representation is both correct and elegant.
 We are also able to correctly identify and report all syntactic errors.
 We believe that the quality of syntactic error printing is generally good,
 though could be improved by determining token length.
\end_layout

\begin_layout Paragraph
Semantic Analysis
\end_layout

\begin_layout Standard
Our semantic analysis correctly identifies all semantic errors.
 We also believe that quality of semantic error printing is very high.
 We are able to identify multiple errors, and clearly show both declaration
 and following usage, where suitable.
\end_layout

\begin_layout Paragraph
Code Generation
\end_layout

\begin_layout Standard
Our compiler is able to generate functionally correct code for all of our
 tests.
 The code generated by our compiler (before optimisation) always has at
 most as many instructions as code generated by the reference compiler.
\end_layout

\begin_layout Subsubsection
Performance
\end_layout

\begin_layout Standard
TODO: Try some simple benchmarking
\end_layout

\begin_layout Subsubsection
Future development
\end_layout

\begin_layout Standard
We believe that our parser forms a sound basis for future development:
\end_layout

\begin_layout Enumerate

\emph on
Altering or adding new features to the grammar and/or AST can be done fairly
 easily
\emph default
.
 One benefit to using 
\family typewriter
pigeon
\family default
 is that changes to the grammar are fairly simple.
 We should only need to make one change to add a new feature, by simply
 adding another parsing rule.
 Adding AST nodes is also a very easy process.
 AST nodes need only implement a 
\family typewriter
String
\family default
 function, as well as a 
\family typewriter
walkNode
\family default
 function that tells a visitor how to visit any child nodes.
\end_layout

\begin_layout Enumerate

\emph on
Semantic checks are simple and powerful
\emph default
.
 Our semantic checking is done using a stack.
 Type checking is as simple as writing one function with what you expect
 to see, and one function to say it's been seen.
\end_layout

\begin_layout Enumerate

\emph on
Code generation has been designed with extensibility in mind
\emph default
.
 We produce an intermediate low-level (instruction) representation of our
 code in the back-end, before generating ARM assembly.
 This means that we could conceivably very easily change the output of our
 compiler to another low-level language.
 Our high-level (AST) representation is clear and concise, and the design
 of 
\family typewriter
code_generator.go
\family default
 would also make it a simple process to generate a high-level language output
 instead.
\end_layout

\begin_layout Enumerate

\emph on
We provide all the tools required to make changes confidently
\emph default
.
 Our project has extensive testing and documentation, allowing future developers
 to be confident that their changes won't affect legacy features.
 Our makefile provides recipes for automatic styling and linting of code,
 ensuring that our code is consistent and always kept as simple as possible.
\end_layout

\begin_layout Standard
We have proven these claims by developing several complex extension features.
\end_layout

\begin_layout Subsection
Design Choices
\end_layout

\begin_layout Standard
We will now discuss the design choices we made during development of the
 
\family typewriter
gowacc
\family default
 compiler.
\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Subsubsection
AST Visitor
\end_layout

\begin_layout Subsubsection
Error Handling
\end_layout

\begin_layout Subsubsection
Code Generator
\end_layout

\begin_layout Subsection
Extension Features
\end_layout

\begin_layout Standard
We will now discuss the additional features that our compiler implements,
 beyond what is required by the specification.
\end_layout

\begin_layout Subsubsection
For Loops
\end_layout

\begin_layout Subsubsection
Switch Statements
\end_layout

\begin_layout Subsubsection
Unicode Characters
\end_layout

\begin_layout Subsubsection
Structures
\end_layout

\begin_layout Subsubsection
Pointer Types
\end_layout

\begin_layout Subsubsection
Improved Register Allocation
\end_layout

\begin_layout Subsubsection
Dynamic Types
\end_layout

\begin_layout Subsubsection
Future Extensions
\end_layout

\begin_layout Section
Development of the 
\family typewriter
gowacc
\family default
 Compiler
\end_layout

\begin_layout Subsection
Group Coordination
\end_layout

\begin_layout Standard
Our group used several tools to communicate effectively, assign tasks, and
 ensure that each member was writing functionally-correct, well-designed,
 well-documented, and well-tested code.
\end_layout

\begin_layout Subsubsection
Communication
\end_layout

\begin_layout Standard
Throughout the project, we made use of the group messaging application,
 Slack, to keep each other updated on progress, and whenever possible, we
 made effort to work in the same place.
 This decision made debugging much easier, as group members could easily
 contact the person responsible for introducing a bug - who would have a
 much clearer idea on how to solve the issue.
 Overall, the level of communication between group members was excellent.
\end_layout

\begin_layout Subsubsection
Task Assignment
\end_layout

\begin_layout Standard
During the first milestone, we used GitLab issues to assign tasks between
 the group.
 We wrote a list of the code that needed to be written (e.g.
 generating a parse tree, generating the AST, writing syntax errors, implementin
g a type checker, writing semantic errors, writing a test suite, etc.).
 We then each claimed issues to work on.
 Whilst this was a fairly effective method for assigning tasks, we felt
 that it was unrealistic for one person to claim such a large chunk of work,
 and complete it entirely individually.
 It also meant that group members failed to gain an understanding of parts
 of the codebase that were written by others.
 For these reasons, for the later milestones, we decided to take a more
 ad-hoc approach.
\end_layout

\begin_layout Standard
During the final two milestones, we used a Google Sheets spreadsheet, which
 listed a number of small tasks, and had boxes for writing the code, documentati
on, testing and quality reviews.
 We enforced that every member of the group should take some part in each
 task (this could be development, documentation, testing or reviewing) -
 thus ensuring that the entire group developed a good knowledge of the full
 code-base.
 There was also a space to write notes.
\end_layout

\begin_layout Standard
Overall, we believe our task allocation was both fair and efficient, and
 this is demonstrated by the group's WebPA scores.
 In future projects, especially with large and spread out teams, we would
 like to make further use of GitLab issues, as was done in the first milestone,
 though in this case, due to us mostly working together, we felt that GitLab
 issues created more of a burden than they worth, and so the ad-hoc approach
 was more appropriate.
\end_layout

\begin_layout Subsection
Development
\end_layout

\begin_layout Standard
Our group made use of several tools and strategies to ensure that we developed
 high-quality code.
\end_layout

\begin_layout Subsubsection
Version Control
\end_layout

\begin_layout Standard
We used Git for version control, using the college's provided GitLab repository.
\end_layout

\begin_layout Standard
We followed a consistent style for all of our commit descriptions.
 All commits were required to start with a capital letter, be less than
 72 characters long, be in present tense, and not end with a full-stop.
 We also enforced that commits should be short, and in general, only affect
 a single file.
\end_layout

\begin_layout Standard
All major features were developed on feature branches, and we required that
 all pushes to the 
\family typewriter
master
\family default
 branch must compile, and should not fail any more tests than the previous
 commit on 
\family typewriter
master
\family default
.
 Feature branches were required to have the format 
\family typewriter
doc-username/feature-name
\family default
.
 We also ensured that feature branches were merged in at the end of each
 day, to reduce merge conflicts.
\end_layout

\begin_layout Standard
Overall, we found that our use of Git promoted a very efficient work-flow,
 allowing all members to work concurrently, and to easily keep up-to-date
 with and search for recent changes.
 In future projects, we would prefer to make use of Git hooks (to enforce
 our standards more effectively), and tools such as 
\family typewriter
godoc.org
\family default
 and 
\family typewriter
goreport.com
\family default
, although unfortunately these changes would require Master permissions
 and public visibility respectively, which are not afforded by the department's
 provided repositories.
\end_layout

\begin_layout Subsubsection
Code Style
\end_layout

\begin_layout Standard
We enforced that all code pushed to GitLab had been formatted with 
\family typewriter
gofmt -s
\family default
 and 
\family typewriter
goimports
\family default
.
 These tools ensure standardised formatting of the code and correct, well-ordere
d imports respectively.
 Using these tools was very helpful, as there was no need to write or follow
 a style guide, since the correct style is forced by the tools.
\end_layout

\begin_layout Standard
Code style can be automatically corrected with the recipe, 
\family typewriter
make fmt
\family default
.
\end_layout

\begin_layout Subsubsection
Code Quality
\end_layout

\begin_layout Standard
We ensure code quality by concurrently running a collection of community-develop
ed tools: 
\family typewriter
deadcode
\family default
, 
\family typewriter
dupl
\family default
, 
\family typewriter
errcheck
\family default
, 
\family typewriter
gas
\family default
, 
\family typewriter
goconst
\family default
, 
\family typewriter
gocyclo
\family default
, 
\family typewriter
gofmt -s
\family default
, 
\family typewriter
goimports
\family default
, 
\family typewriter
golint
\family default
, 
\family typewriter
gosimple
\family default
, 
\family typewriter
gotype
\family default
, 
\family typewriter
gotypex
\family default
, 
\family typewriter
ineffassign
\family default
, 
\family typewriter
interfacer
\family default
, 
\family typewriter
lll
\family default
, 
\family typewriter
maligned
\family default
, 
\family typewriter
megacheck
\family default
, 
\family typewriter
misspell
\family default
, 
\family typewriter
nakedret
\family default
, 
\family typewriter
staticcheck
\family default
, 
\family typewriter
structcheck
\family default
, 
\family typewriter
unconvert
\family default
, 
\family typewriter
unparam
\family default
, 
\family typewriter
unused
\family default
, 
\family typewriter
varcheck
\family default
, and 
\family typewriter
vet
\family default
.
 These check various metrics on our code.
 Some check that our style is correct such as 
\family typewriter
gofmt
\family default
 and 
\family typewriter
lll
\family default
 (which checks for lines longer than 80 characters), whilst others look
 for code smells, such as 
\family typewriter
vet
\family default
 (which looks for common mistakes) and 
\family typewriter
gocyclo
\family default
 (which ensures that the cyclomatic complexity of all functions is under
 10).
 These tools were extremely useful, since if our linter doesn't return any
 warnings, we can be fairly confident that the code we have written is of
 very high quality.
\end_layout

\begin_layout Standard
Code quality can be automatically checked with the recipe, 
\family typewriter
make lint
\family default
.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
We required that all exported constants, variables, interfaces, structs
 and functions were accompanied by a GoDoc comment.
 In many simple cases (such as constructors), they were largely unnecessary,
 but we made the decision to keep them in order to avoid 
\family typewriter
golint
\family default
 warnings.
 In complex cases, these comments were extremely useful in helping members
 of group to understand parts of the codebase which they hadn't written.
\end_layout

\begin_layout Standard
We also have a 
\family typewriter
doc.go
\family default
 in our 
\family typewriter
gowacc
\family default
 package, which explains the overall project architecture, and how the 
\family typewriter
gowacc
\family default
 binary should be used.
\end_layout

\begin_layout Standard
Documentation can be automatically generated with the recipe, 
\family typewriter
make docs
\family default
.
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Standard
Our group used testing to guide us through the development process, and
 as a harness to ensure that future changes would not break working features.
 We spent a lot of time writing tests, however we believe that thorough
 testing was integral to our success in this project.
\end_layout

\begin_layout Subsubsection
Unit Testing
\end_layout

\begin_layout Standard
Where necessary throughout our code, we use unit testing to ensure the correct
 functionality is maintained.
\end_layout

\begin_layout Subsubsection
Functional Testing
\end_layout

\begin_layout Standard
We spent a not-insignificant amount of time developing a web-based Ruby
 test suite, which is forked from the first year ARM project's test suite.
 The test suite tests all of the provided example WACC files, as well as
 a significant number of additional tests that cover both edge cases of
 the original specification and the functionality of our extensions.
\end_layout

\begin_layout Standard
For the front-end, we compare our compiler's exit code, as well as the generated
 AST, with a saved copy of the reference compiler's output.
\end_layout

\begin_layout Standard
For the back-end, we compare the result of our compiled code's execution
 with a saved copy of the result of the reference compiler and emulator.
 We also present our assembly and the reference assembly, side-by-side,
 to allow for easy debugging and comparison of performance.
\end_layout

\begin_layout Standard
Automatic functional tests can be run with the recipe, 
\family typewriter
make tests
\family default
.
\end_layout

\end_body
\end_document
