#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The 
\family typewriter
gowacc
\family default
 WACC Compiler
\end_layout

\begin_layout Author
Alexander Clarke (
\family typewriter
ac3716@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Qiang Feng (
\family typewriter
qf316@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Jordan Spooner (
\family typewriter
js4416@ic.ac.uk
\family default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Laurence Squires (
\family typewriter
ljs116@ic.ac.uk
\family default
)
\end_layout

\begin_layout Date
December 2017
\end_layout

\begin_layout Section
About the 
\family typewriter
gowacc
\family default
 Compiler
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
The 
\family typewriter
gowacc
\family default
 compiler is a tool, developed using Go, that compiles WACC source code
 into ARM assembly.
\end_layout

\begin_layout Subsubsection
Specification
\end_layout

\begin_layout Standard
We believe that our compiler largely meets the specification:
\end_layout

\begin_layout Paragraph
Lexical Analysis
\end_layout

\begin_layout Standard
Our compiler does not perform lexical analysis.
 We chose to use a parsing expression grammar, which means that lexing and
 parsing is performed in a single pass.
 This has some minor stylistic consequences in our grammar, but does not
 significantly affect how we meet much of the specification.
 It does, however, affect how much we can tell about errors.
 For example, consider the (incorrect) statement:
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
intx = 3
\end_layout

\begin_layout Standard
Most parsers would store 
\family typewriter
intx
\family default
 as a token, thus allowing the compiler to identify the full token responsible
 for the error.
 Since we do not have tokens, detecting where an error ends is much more
 difficult, and was not supported by our parser generator.
 We forked our parser generator to add some additional functionality, however
 we didn't attempt to find the end of an error.
\end_layout

\begin_layout Standard
If we were to continue development on this compiler, we would probably choose
 to redevelop the parser using 
\family typewriter
goyacc
\family default
 instead of 
\family typewriter
pigeon
\family default
.
 This would allow us to improve the quality of error messages significantly,
 and would require less work than further forks to 
\family typewriter
pigeon
\family default
.
 It may also lead to increased performance in certain cases.
\end_layout

\begin_layout Paragraph
Syntactic Analysis
\end_layout

\begin_layout Standard
We carefully designed our AST from scratch, and tested it thoroughly against
 the reference compiler's AST, using the provided example programs as well
 as many of our own, more complex, example programs.
 We are confident that our internal representation is both correct and elegant.
 We are also able to correctly identify and report all syntactic errors.
 We believe that the quality of syntactic error printing is generally good,
 though could be improved by determining token length.
\end_layout

\begin_layout Paragraph
Semantic Analysis
\end_layout

\begin_layout Standard
Our semantic analysis correctly identifies all semantic errors.
 We also believe that quality of semantic error printing is very high.
 We are able to identify multiple errors, and clearly show both declaration
 and following usage, where suitable.
\end_layout

\begin_layout Paragraph
Code Generation
\end_layout

\begin_layout Standard
Our compiler is able to generate functionally correct code for all of our
 tests.
 The code generated by our compiler (before optimisation) always has at
 most as many instructions as code generated by the reference compiler.
\end_layout

\begin_layout Subsubsection
Performance
\end_layout

\begin_layout Standard
Benchmarking of the compiler was done using the time golang package, each
 measurement is an average of 50 runs rounded to 2sf.
 The AST generation takes up the most amount of time when using the compilier
 as it includes loading the file, parsing and generating the AST.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarySortTree.wacc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hashTable.wacc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ticTacToe.wacc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source Code Length (lines)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
68
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
312
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1061
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly Code Length (lines)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
369
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1379
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4104
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AST Generation (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150.64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
603.94
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Semantic Checking (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.83
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.66
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.94
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly Generation (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.70
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly Saving (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.90
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.40
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32.02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162.98
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
634.24
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Performance metrics of the compiler
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Future development
\end_layout

\begin_layout Standard
We believe that our parser forms a sound basis for future development:
\end_layout

\begin_layout Enumerate

\emph on
Altering or adding new features to the grammar and/or AST can be done fairly
 easily
\emph default
.
 One benefit to using 
\family typewriter
pigeon
\family default
 is that changes to the grammar are fairly simple.
 We should only need to make one change to add a new feature, by simply
 adding another parsing rule.
 Adding AST nodes is also a very easy process.
 AST nodes need only implement a 
\family typewriter
String
\family default
 function, as well as a 
\family typewriter
walkNode
\family default
 function that tells a visitor how to visit any child nodes.
 Nodes that can be optimised by the propagation algorithm must implement
 the 
\family typewriter
MapExpressions
\family default
 function to allow the child expressions to be altered.
 Any TypeNodes in the AST must also implement an 
\family typewriter
equals
\family default
 and 
\family typewriter
hash
\family default
 function for use by the type checker and symbol table.
\end_layout

\begin_layout Enumerate

\emph on
Semantic checks are simple and powerful
\emph default
.
 The semantic checker uses the 
\family typewriter
SearchForIdent
\family default
 function in the symbol table to find declaration errors and the 
\family typewriter
Seen
\family default
 function in the type checker to find type errors.
 Our type checking is done using a stack.
 Type checking is as simple as writing one function with what you expect
 to see, and one function to say it's been seen.
 The type checker then uses the TypeNodes 
\family typewriter
equals
\family default
 function to check for valid type matching and various forms of
\family typewriter
 Expectance
\family default
 to resolve and determine if further checks are necessary.
 
\end_layout

\begin_layout Enumerate

\emph on
Code generation has been designed with extensibility in mind
\emph default
.
 We produce an intermediate low-level (instruction) representation of our
 code in the back-end, before generating ARM assembly.
 This means that we could conceivably very easily change the output of our
 compiler to another low-level language.
 Our high-level (AST) representation is clear and concise, and the design
 of 
\family typewriter
code_generator.go
\family default
 would also make it a simple process to generate a high-level language output
 instead.
\end_layout

\begin_layout Enumerate

\emph on
We provide all the tools required to make changes confidently
\emph default
.
 Our project has extensive testing and documentation, allowing future developers
 to be confident that their changes won't affect legacy features.
 Our makefile provides recipes for automatic styling and linting of code,
 ensuring that our code is consistent and always kept as simple as possible.
\end_layout

\begin_layout Standard
We have proven these claims by developing several complex extension features.
\end_layout

\begin_layout Subsection
Design Choices
\end_layout

\begin_layout Standard
We will now discuss the design choices we made during development of the
 
\family typewriter
gowacc
\family default
 compiler.
\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Subsubsection
AST Visitor
\end_layout

\begin_layout Subsubsection
Error Handling
\end_layout

\begin_layout Paragraph
Syntax Errors
\end_layout

\begin_layout Paragraph
Semantic Errors
\end_layout

\begin_layout Standard
Semantic errors are handled by storing a slice of Errors interface, that
 stores information about the type of error, and any other useful information
 that a user might want.
 For example, if an identifier is the wrong type for an expression it will
 state where that identifier was declared.
 When an error is generated in the semantic checker the type checker is
 frozen on the relevant node and unfrozen when that node is left.
 This stops any further irrelevant error messages from printing until the
 erroneous region of code has passed.
 E.g.
 in the code 
\family typewriter
x = true; x = 7;
\family default
 a re-declaration error has been found on the second statement and the type
 checker is frozen to stop the following irrelevant type error from also
 being reported.
 These Errors can be then printed in the main function, limiting the number
 of errors printed if there are too many.
 Whenever an error is found in the semantic checking, it is added to the
 slice of Errors.
 
\end_layout

\begin_layout Subsubsection
Code Generator
\end_layout

\begin_layout Subsection
Extension Features
\end_layout

\begin_layout Standard
We will now discuss the additional features that our compiler implements,
 beyond what is required by the specification.
\end_layout

\begin_layout Subsubsection
Unicode Characters
\end_layout

\begin_layout Subsubsection
For Loops
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
for int i=0; i<5; i=i+1 do
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

skip
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
end
\end_layout

\begin_layout Standard
\noindent
\align block
For loops take a similar grammar to while loops, using do and end to denote
 the new scope.
 For loops take two additional statements, before and after the condition,
 where the first is executed before the loop begins, and the second is executed
 before checking the condition again.
\end_layout

\begin_layout Subsubsection
Switch Statements
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
when i
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
case 2, 3:
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

skip
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

end
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
else:
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

skip
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

end
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
fi
\end_layout

\begin_layout Standard
Our switch statements are based upon the ruby when statement.
 This was because most switch statements in other languages use curly braces
 which are not in the wacc language.
 There are not break statements, instead you can indicate more expressions
 after commas.
 The default case must be the last case.
 
\end_layout

\begin_layout Subsubsection
\noindent
Structures
\end_layout

\begin_layout Quotation

\family typewriter
struct List is
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

$List next;
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

int value;
\end_layout

\begin_layout Quotation

\family typewriter
end
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\begin_layout Quotation

\family typewriter
begin
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

$List a = new List(null, 1);
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

$List b = new List(a, 2);
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

$List c = new List(b, 4);
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

println c.value; # prints 4
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

c.next = a;
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

$List next = c.next;
\end_layout

\begin_layout Quotation

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

println next.value # prints 1
\end_layout

\begin_layout Quotation

\family typewriter
end 
\end_layout

\begin_layout Standard
Structs have also been implemented in WACC.
 They are declared at the top section of the program and can be constructed
 using the “new” keyword in the program and function bodies.
 The declaration of the struct includes information such as the struct name,
 its member names and member types.
 The struct is represented internally as a pointer to the struct object
 on the heap, where each member is stored in the order they are declared.
 The members of a struct can be accessed and changed and can also be other
 (or the same) struct, meaning tree like and cyclic structures are possible
 with them.
 The structs can be declared with implicit types and can be passed as arguments
 to functions or functions can be declared to operate on a struct type.
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
#Declaration, a is field of MyType
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
int MyType.f(int i) is
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

this.a = 2;
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

return i
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
end
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset


\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
#Calling, t is a MyType
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
i := call t.f(1);
\end_layout

\begin_layout Standard
Instead of classes, you can call functions on structs.
 Calling a function on a struct is comparable to having a parameter of the
 type of the struct, with identifier this.
\end_layout

\begin_layout Subsubsection
Pointers and Garbage Collection
\end_layout

\begin_layout Subsubsection
Implicit Types
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
begin
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

getThirdChar(list) is
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset


\begin_inset Formula $\qquad$
\end_inset

return chr list[2]
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

end
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

x := [1, 2, 67];
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

#c is calculated to have type Char
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

c := call getThirdChar(x); 
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
\begin_inset Formula $\qquad$
\end_inset

println c
\end_layout

\begin_layout Quotation
\noindent
\align block

\family typewriter
end 
\end_layout

\begin_layout Standard
We introduced full implicit typing to the WACC language without having to
 change the type checking or semantic checking.Our implementation of implicit
 typing allows type information to still be present in the program, but
 not necessary as the types of variables, parameters and return types can
 all be fully derived even when no types are originally given.
 This allows the user the option to add type information where they choose,
 this being useful for reference and clarity.
 In addition, the extra type information will still be used by the type
 checker, although it is not necessary to verify the types of the program
 and return any semantic errors.
 This was done by adding a new TypeNode called DynamicTypeNode.
 A DynamicTypeNode starts uninitialised and without a type but over the
 semantic checking pass it will resolve to a type or point to another DynamicTyp
eNode as its type.
 When the type checker calls equals on an uninitialised DynamicTypeNode
 then the node reduces down to the type it has received.
 If both are DynamicTypeNodes then they must have the same type, so they
 link together and point to the same type (as well as any other nodes pointing
 to either).
 If the DynamicTypeNode resolves to an array, pair or pointer then the inner
 type contained in these types is expanded to another DynamicTypeNode.
 The DynamicTypeNode then returns the type it has to the type checker which
 goes through the normal process of checking the types are valid.
 Once the pass is over, the semantic checker checks the symbol table for
 any remaining unresolved DynamicTypeNodes and throws an error if present.
 A DynamicTypeNode is created by the grammar whenever a Type has no string
 value, or when declare is used with ":=", this allows function parameters,
 return types, struct members and variables to all have implicit types.
\end_layout

\begin_layout Subsubsection
Function Overloading
\end_layout

\begin_layout Standard
Function overloading is done by creating a hash of the parameter types,
 used to compare between the distinct functions with different parameters
 with the same identifier.
 The hash is also used to create distinct labels in the code generation.
\end_layout

\begin_layout Subsubsection
Constant Propagation and Array Bounds Checking
\end_layout

\begin_layout Standard
Constant propagation has been implemented that will simplify expressions
 if they evaluate to a constant expression, taking into account any previously
 known constant variables.
 E.g.
 
\family typewriter
x = true || false;
\family default
 is replaced by
\family typewriter
 x = true;
\family default
 and
\family typewriter
 y = 2; x = y * 2;
\family default
 is replaced by 
\family typewriter
y = 2; x = 4;.

\family default
 This also works for constant arrays, E.g.
 
\family typewriter
y = [5,6]; x = y[0] + 5;
\family default
 is replaced by
\family typewriter
 y = [5,6]; x = 10;.

\family default
 This allows any expression present in the tree to be replaced if the value
 it evaluates to is constant.
 In addition, we also check at compile time for various runtime errors such
 as array bounds errors, overflow and divide and mod by zero errors.
 This is possible because if the index of an array access is simplified
 to a constant and the array length is also known to be constant then we
 can check if the index is valid.
 Furthermore, we can simplify all constant integer expressions and check
 for overflows, divide by zero and mod by zero errors at compile time.
 Giving the user the line the error occurred on, the operation responsible
 and the result of the operation that is too big to store in 4 bytes.
\end_layout

\begin_layout Subsubsection
Future Extensions
\end_layout

\begin_layout Section
Development of the 
\family typewriter
gowacc
\family default
 Compiler
\end_layout

\begin_layout Subsection
Group Coordination
\end_layout

\begin_layout Standard
Our group used several tools to communicate effectively, assign tasks, and
 ensure that each member was writing functionally-correct, well-designed,
 well-documented, and well-tested code.
\end_layout

\begin_layout Subsubsection
Communication
\end_layout

\begin_layout Standard
Throughout the project, we made use of the group messaging application,
 Slack, to keep each other updated on progress, and whenever possible, we
 made effort to work in the same place.
 This decision made debugging much easier, as group members could easily
 contact the person responsible for introducing a bug - who would have a
 much clearer idea on how to solve the issue.
 Overall, the level of communication between group members was excellent.
\end_layout

\begin_layout Subsubsection
Task Assignment
\end_layout

\begin_layout Standard
During the first milestone, we used GitLab issues to assign tasks between
 the group.
 We wrote a list of the code that needed to be written (e.g.
 generating a parse tree, generating the AST, writing syntax errors, implementin
g a type checker, writing semantic errors, writing a test suite, etc.).
 We then each claimed issues to work on.
 Whilst this was a fairly effective method for assigning tasks, we felt
 that it was unrealistic for one person to claim such a large chunk of work,
 and complete it entirely individually.
 It also meant that group members failed to gain an understanding of parts
 of the codebase that were written by others.
 For these reasons, for the later milestones, we decided to take a more
 ad-hoc approach.
\end_layout

\begin_layout Standard
During the final two milestones, we used a Google Sheets spreadsheet, which
 listed a number of small tasks, and had boxes for writing the code, documentati
on, testing and quality reviews.
 We enforced that every member of the group should take some part in each
 task (this could be development, documentation, testing or reviewing) -
 thus ensuring that the entire group developed a good knowledge of the full
 code-base.
 There was also a space to write notes.
\end_layout

\begin_layout Standard
Overall, we believe our task allocation was both fair and efficient, and
 this is demonstrated by the group's WebPA scores.
 In future projects, especially with large and spread out teams, we would
 like to make further use of GitLab issues, as was done in the first milestone,
 though in this case, due to us mostly working together, we felt that GitLab
 issues created more of a burden than they worth, and so the ad-hoc approach
 was more appropriate.
\end_layout

\begin_layout Subsection
Development
\end_layout

\begin_layout Standard
Our group made use of several tools and strategies to ensure that we developed
 high-quality code.
\end_layout

\begin_layout Subsubsection
Version Control
\end_layout

\begin_layout Standard
We used Git for version control, using the college's provided GitLab repository.
\end_layout

\begin_layout Standard
We followed a consistent style for all of our commit descriptions.
 All commits were required to start with a capital letter, be less than
 72 characters long, be in present tense, and not end with a full-stop.
 We also enforced that commits should be short, and in general, only affect
 a single file.
\end_layout

\begin_layout Standard
All major features were developed on feature branches, and we required that
 all pushes to the 
\family typewriter
master
\family default
 branch must compile, and should not fail any more tests than the previous
 commit on 
\family typewriter
master
\family default
.
 Feature branches were required to have the format 
\family typewriter
doc-username/feature-name
\family default
.
 We also ensured that feature branches were merged in at the end of each
 day, to reduce merge conflicts.
\end_layout

\begin_layout Standard
Overall, we found that our use of Git promoted a very efficient work-flow,
 allowing all members to work concurrently, and to easily keep up-to-date
 with and search for recent changes.
 In future projects, we would prefer to make use of Git hooks (to enforce
 our standards more effectively), and tools such as 
\family typewriter
godoc.org
\family default
 and 
\family typewriter
goreport.com
\family default
, although unfortunately these changes would require Master permissions
 and public visibility respectively, which are not afforded by the department's
 provided repositories.
\end_layout

\begin_layout Subsubsection
Code Style
\end_layout

\begin_layout Standard
We enforced that all code pushed to GitLab had been formatted with 
\family typewriter
gofmt -s
\family default
 and 
\family typewriter
goimports
\family default
.
 These tools ensure standardised formatting of the code and correct, well-ordere
d imports respectively.
 Using these tools was very helpful, as there was no need to write or follow
 a style guide, since the correct style is forced by the tools.
\end_layout

\begin_layout Standard
Code style can be automatically corrected with the recipe, 
\family typewriter
make fmt
\family default
.
\end_layout

\begin_layout Subsubsection
Code Quality
\end_layout

\begin_layout Standard
We ensure code quality by concurrently running a collection of community-develop
ed tools:
\family typewriter
deadcode
\family default
, 
\family typewriter
dupl
\family default
, 
\family typewriter
errcheck
\family default
, 
\family typewriter
gas
\family default
, 
\family typewriter
goconst
\family default
, 
\family typewriter
gocyclo
\family default
, 
\family typewriter
gofmt -s
\family default
, 
\family typewriter
goimports
\family default
, 
\family typewriter
golint
\family default
, 
\family typewriter
gosimple
\family default
, 
\family typewriter
gotype
\family default
, 
\family typewriter
gotypex
\family default
, 
\family typewriter
ineffassign
\family default
, 
\family typewriter
interfacer
\family default
, 
\family typewriter
lll
\family default
, 
\family typewriter
maligned
\family default
, 
\family typewriter
megacheck
\family default
, 
\family typewriter
misspell
\family default
, 
\family typewriter
nakedret
\family default
, 
\family typewriter
staticcheck
\family default
, 
\family typewriter
structcheck
\family default
, 
\family typewriter
unconvert
\family default
, 
\family typewriter
unparam
\family default
, 
\family typewriter
unused
\family default
, 
\family typewriter
varcheck 
\family default
and
\family typewriter
 vet
\family default
.
 These check various metrics on our code.
 Some check that our style is correct such as 
\family typewriter
gofmt
\family default
 and 
\family typewriter
lll
\family default
 (which checks for lines longer than 80 characters), whilst others look
 for code smells, such as 
\family typewriter
vet
\family default
 (which looks for common mistakes) and 
\family typewriter
gocyclo
\family default
 (which ensures that the cyclomatic complexity of all functions is under
 10).
 These tools were extremely useful, since if our linter doesn't return any
 warnings, we can be fairly confident that the code we have written is of
 very high quality.
\end_layout

\begin_layout Standard
Code quality can be automatically checked with the recipe, 
\family typewriter
make lint
\family default
.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
We required that all exported constants, variables, interfaces, structs
 and functions were accompanied by a GoDoc comment.
 In many simple cases (such as constructors), they were largely unnecessary,
 but we made the decision to keep them in order to avoid 
\family typewriter
golint
\family default
 warnings.
 In complex cases, these comments were extremely useful in helping members
 of group to understand parts of the codebase which they hadn't written.
\end_layout

\begin_layout Standard
We also have a 
\family typewriter
doc.go
\family default
 in our 
\family typewriter
gowacc
\family default
 package, which explains the overall project architecture, and how the 
\family typewriter
gowacc
\family default
 binary should be used.
\end_layout

\begin_layout Standard
Documentation can be automatically generated with the recipe, 
\family typewriter
make docs
\family default
.
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Standard
Our group used testing to guide us through the development process, and
 as a harness to ensure that future changes would not break working features.
 We spent a lot of time writing tests, however we believe that thorough
 testing was integral to our success in this project.
\end_layout

\begin_layout Subsubsection
Unit Testing
\end_layout

\begin_layout Standard
Where necessary throughout our code, we use unit testing to ensure the correct
 functionality is maintained for specific individual functions.
\end_layout

\begin_layout Subsubsection
Functional Testing
\end_layout

\begin_layout Standard
We spent a not-insignificant amount of time developing a web-based Ruby
 test suite, which is forked from the first year ARM project's test suite.
 The test suite tests all of the provided example WACC files, as well as
 a significant number of additional tests that cover both edge cases of
 the original specification and the functionality of our extensions.
\end_layout

\begin_layout Standard
For the front-end, we compare our compiler's exit code, as well as the generated
 AST, with a saved copy of the reference compiler's output.
\end_layout

\begin_layout Standard
For the back-end, we compare the result of our compiled code's execution
 with a saved copy of the result of the reference compiler and emulator.
 We also present our assembly and the reference assembly, side-by-side,
 to allow for easy debugging and comparison of performance.
\end_layout

\begin_layout Standard
Automatic functional tests can be run with the recipe, 
\family typewriter
make tests
\family default
.
\end_layout

\end_body
\end_document
